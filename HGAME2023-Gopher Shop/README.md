 

### GopherShop

> flag：`hgame{GopherShop_M@gic_1nt_0verflow}`
>
> 题目源码：https://github.com/ek1ng/My-CTF-Challenges

> 有选手误认为是需要用gopher协议的知识，题目叫做Gopher Shop只是因为后端是Go写的，Go语言开发者经常会被称为gopher，从题目描述`Gopher？听说协会的Web手们都会一点Go,也许这是协会学长开的吧。`和页面上两个Go的吉祥物也能看出，和搜到的SSRF用Gopher协议打内网是完全两码事情。

题目考察的漏洞点是golang整数溢出漏洞，uint类型在64位机器上运行时为uint64，最大值为`18446744073709551615`,最小值为`0`，超出范围都会溢出。

#### 解法一

购买商品的校验逻辑为

```PHP
money := uint(number) * price
//校验是否买的起
if err != nil || number < 1 || money > user.Balance {
   context.JSON(400, gin.H{"error": "invalid request"})
   return
}
user.Balance -= uint(number) * price
```

这里存在整数溢出的问题，同时又没有对购买的数量做出限制，因此可以购买一个溢出后刚好够的数量。这个做法这里只能恰好买这么多，开局只给了10块，多一个少一个都不够。

构造溢出`1844674407370955162`*`10` = `18446744073709551620`=`4`

![image-20230126132300704](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/202301261323781.png)

这里flag的价格是unit64溢出后的钱的一半往上，溢出后基本卖光然后就可以买得起了。这里我卖到只剩1个然后兑换flag。

![image-20230126132308871](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/202301261323940.png)

一些可能会有疑惑的点：

这里可能有人会发现购买后前端这里显示的数值和接口返回的数值会不太一样，按照前端显示的全部卖是卖不出去的，这是因为这个数值太大了，前端渲染的时候把尾数抹了

![image-20230126132317392](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/202301261323456.png)

如果我们把买到的全部卖出去是只能赚4块，因为也是和上面一样的溢出，都会被认为是4块钱，卖的时候也需要考虑一下溢出。

![image-20230126132330379](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/202301261323430.png)

#### 解法二

条件竞争买/卖的接口->打整数溢出

条件竞争的利用点在于在多个连续的请求发给服务端时，数据库中存储的值还没有被前一个请求所改变，就被后一个请求所取出，导致都通过了`if`中的逻辑判断，在后面扣除余额/数量的时候变成负数，导致`Overflow`/`Underflow`。

如果是对于卖的接口条件竞争，会出现比如说有一个苹果，两个卖1个苹果的请求过来都过了if语句，那么第二个请求后端会认为是`-1`个苹果也就是`18446744073709551615`个。

如果是对于买的接口条件竞争，会出现比如说有10块钱，两个买1个苹果的请求过来都过了if语句，那么第二个请求后端会认为是`-10`元也就是`18446744073709551606`元。

有很多选手写的exp都是买和卖的请求一直发，这样就会突然发现自己有很多钱/很多苹果，这里其实是因为触发了整数溢出。

#### 如何修复

1. 在购买的逻辑部分，补充购买数量和用户库存的限制，禁止超过库存数量购买。
2. 将乘法改为除法，避免溢出或者对于计算后的值，写额外的判断逻辑来看是否存在整数溢出。
3. 对金额和库存等变量做加锁机制来防止并发操作带来的条件竞争问题。

出题人的一些额外的想法：

go的编译器什么时候会报溢出的错误什么时候不会呢？

![image-20230126132341137](https://ek1ng-typora.oss-cn-hangzhou.aliyuncs.com/img/202301261323192.png)

go并不会在计算的时候判断溢出，只会在赋值的时候判断溢出，会报类型错误（根据变量类型限制了赋值的范围），因此当给c和d赋值一个会溢出的数的时候就报错了，同理下面的Println也是先将传入的内容计算后赋值给一个变量，然后再输出。
